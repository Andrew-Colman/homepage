---
layout: doctrine
title: Doctrina
permalink: /doctrine/es
---

    <section lang="es">
      <h1 style="margin-bottom: 0px">La Doctrina Rails</h1>
      <p style="margin-top: 0"><small style="color: grey">Por David Heinemeier Hansson en Enero de 2016</small></p>

      <figure class="right">
        <img src="/images/doctrine.png" alt="La Doctrina Rails">
      </figure>

      <p>El fenomenal ascenso de Ruby on Rails a la prominencia se debió en gran parte a su despegue a la tecnología y el tiempo novedosos. Pero las ventajas tecnológicas se erosionan con el tiempo y el buen momento no sostiene los movimientos por sí solo a largo plazo. Por lo tanto, se necesita una explicación más amplia de cómo Rails no solo sigue siendo relevante, sino también para aumentar su impacto y comunidad. Propongo que el habilitador duradero ha sido y sigue siendo su doctrina controvertida.</p>

      <p>Esta doctrina ha evolucionado durante la última década, pero la mayoría de sus pilares más fuertes también son los fundadores. No pretendo reivindicar la originalidad fundamental de estas ideas. El principal logro de Rails fue unir y cultivar una tribu fuerte en torno a un amplio conjunto de pensamientos heréticos sobre la naturaleza de la programación y los programadores.</p>

      <p>Después de todo el preámbulo, aquí tienen los nueve pilares más importantes de la Doctrina Rails, tal como yo los percibo:</p>

      <p>
        <ol>
          <li><a href="#optimize-for-programmer-happiness">Optimización para la felicidad del programador</a></li>
          <li><a href="#convention-over-configuration">Convención sobre configuración</a></li>
          <li><a href="#omakase">La carta al estilo omakase</a></li>
          <li><a href="#no-one-paradigm">Ningún paradigma</a></li>
          <li><a href="#beautiful-code">Exaltar código hermoso</a></li>
          <li><a href="#provide-sharp-knives">Proporcionar cuchillos afilados</a></li>
          <li><a href="#integrated-systems">Valora los sistemas integrados</a></li>
          <li><a href="#progress-over-stability">Progreso sobre estabilidad</a></li>
          <li><a href="#big-tent">Construir una gran tienda de acampar</a></li>
        </ol>
      </p>

      <h2 id="optimize-for-programmer-happiness">Optimización para la felicidad del programador</h2>

      <p>No habría Rails sin Ruby, por lo que es justo que el primer pilar doctrinal se levante directamente de la motivación central para crear Ruby.</p>

      <p>La herejía original de Ruby era, de hecho, colocar la felicidad del programador en un pedestal. Por encima de muchas otras inquietudes válidas y de competencia que antes habían impulsado los lenguajes de programación y los ecosistemas.</p>

      <p>Donde Python podría jactarse de que hay "una y, de preferencia, solo una forma de hacer algo", Ruby disfrutó de la expresividad y la sutileza. Donde Java defendió forzadamente a los programadores para protegerse de ellos mismos, Ruby incluyó una cuerda colgante en el kit de bienvenida. Cuando Smalltalk perforó la pureza del pasaje de mensajes, Ruby acumuló palabras clave y construyó con un apetito casi glotón.</p>

      <p>Ruby era diferente porque valoraba cosas diferentes. Y la mayoría de esas cosas estaban al servicio de este anhelo por la felicidad del programador. Una búsqueda que lo puso en desacuerdo no solo con la mayoría de los otros entornos de programación, sino también con la percepción de lo que era un programador y cómo se suponía que deberían actuar.</p>

      <p>Ruby no solo reconoció, sino que también acomodó y elevó los sentimientos de los programadores. Si son de insuficiencia, capricho o alegría. Matz saltó obstáculos de implementación de asombrosa complejidad para hacer que la máquina pareciera sonreír y halagar a su co-conspirador humano. Ruby está lleno de ilusiones ópticas en las que lo que parece simple, claro y hermoso a los ojos de nuestra mente es en realidad un lío acrobático de cables debajo del capó. Estas opciones no fueron libres (¡pregúntele al equipo de JRuby si está tratando de aplicar ingeniería inversa a esta caja de música mágica!), Por eso es que son tan encomiables.</p>

      <p>Fue esta dedicación a una visión alternativa para la programación y los programadores lo que selló mi historia de amor con Ruby. No era solo la facilidad de su uso, no era solo la estética de los bloques, no era un solo logro técnico. Fue una visión. Una contracultura. Un lugar para que los desajustes del molde de programación profesional existente pertenezcan y se asocien con ideas afines.</p>

      <p>He descrito este descubrimiento de Ruby en el pasado como encontrar un guante mágico que se ajusta perfectamente a mi cerebro. Mejor de lo que nunca hubiera imaginado que un guante pudiera caber. Pero fue incluso más que eso. Fue el evento que marcó mi propia transición personal de "hacer programación porque necesitaba programas" a "hacer programación porque me enamoré de ella como un modo de ejercicio y expresión intelectual". Fue encontrar una <a href="http://www.amazon.com/Flow-Harper-Perennial-Modern-Classics-ebook/dp/B000W94FE6/" target="_blank">fuente de flujo</a> y ser capaz encenderla a voluntad. Para cualquiera que esté familiarizado con el trabajo de Csikszentmihalyi, el impacto de esto es difícil de exagerar.</p>

      <p>No exagero cuando digo que Ruby me transformó y estableció el rumbo para el trabajo de mi vida. Tan profunda fue la revelación. Me imbuyó con un llamado a hacer el trabajo misionero al servicio de la creación de Matz. Para ayudar a difundir esta creación profunda y sus beneficios.</p>

      <p>Ahora puedo imaginar a la mayoría de ustedes sacudiendo la cabeza con incredulidad. No te culpo Si alguien me hubiera descrito la experiencia anterior cuando aún vivía bajo el paradigma de "la programación es solo una herramienta", yo también habría sacudido la cabeza. Y entonces probablemente me hubiera reído del uso excesivo del lenguaje religioso. Pero para que esto sea una cuenta veraz, también tiene que ser honesto, incluso si es desagradable para algunos o incluso para la mayoría.</p>

      <p>De todos modos, ¿qué significó esto para Rails y cómo este principio continúa guiando su evolución? Para responder a eso, creo que es instructivo observar otro principio que se usaba a menudo para describir a Ruby en los primeros días: El principio de la menor sorpresa. Ruby debería comportarse como esperas que lo haga. Esto se describe fácilmente con un contraste con Python:</p>

      <p>
        <code><pre>
    $ irb
    irb(main):001:0> exit
    $ irb
    irb(main):001:0> quit

    $ python
    >>> exit
    Use exit() or Ctrl-D (i.e. EOF) to exit</pre></code>
      </p>

      <p>Ruby acepta exit y quit para acomodar el deseo obvio del programador de salir de su consola interactiva. Python, por otro lado, instruye de manera pediátrica al programador cómo hacer correctamente lo que se solicita, a pesar de que obviamente sabe lo que significa (ya que muestra el mensaje de error). Ese es un ejemplo bastante claro, aunque pequeño, de PoLS.</p>

      <p>La razón por la que PoLS cayó en desgracia para la comunidad Ruby, es su enfoque subjetivo. Pero sorprendentemente, ¿a quién cayó en desgracia? Bueno, a Matz. Y las personas que tambien se sorprenden de la misma manera que él. Tan pronto como la comunidad de Ruby expandió sus filas, la gente comenzó a preguntarse sobre varias cosas diferentes, lo cual fue el motivo de innumerables cartas.</p>

      <p>Entonces, de nuevo, ¿qué tiene esto que ver con Rails? Bueno, Rails ha sido diseñado con un principio similar al Principio de Menos Sorpresa (Para Matz). El principio de la sonrisa más grande (de DHH), que es justo lo que describen sus cualidades: API diseñadas con gran atención a todo lo que me haría sonreír más y más. Cuando lo escribo así, suena casi cómicamente narcisista, e incluso me resulta difícil argumentar contra esa primera impresión.</p>

      <p>Pero crear algo como Ruby o Rails es, al menos desde el principio, una tarea profundamente narcisista. Ambos proyectos surgieron de la mente de un creador singular. Pero quizás estoy proyectando mis propias motivaciones en Matz aquí, así que permítame limitar el alcance de mi proclamación a lo que sé: creé Rails para mí. Para hacerme sonreír, ante todo. Su utilidad estuvo subordinada en muchos grados a su capacidad para hacerme disfrutar más de mi vida. Para enriquecer mi trabajo diario de requisitos de solicitudes y solicitudes de sistemas de información web.</p>

      <p>Al igual que Matz, a veces me esforzaba mucho para cumplir mi principio. Un ejemplo es el Inflector, una clase que comprende lo suficiente de los patrones e irregularidades del idioma inglés para asignar una clase de Persona a una tabla de Personas, Análisis a Análisis, y simplemente Comentario a Comentarios. Este comportamiento ahora se acepta como un elemento incuestionable de Rails, pero los fuegos de la controversia se desataron con gran intensidad en los primeros días cuando aún estábamos uniendo la doctrina y su importancia.</p>

      <p>Otro ejemplo que requirió menos esfuerzo de implementación, pero provocó casi la misma consternación: Array#second hasta #fifth (y #forty_two para trolear). Estos alias fueron muy ofensivos para algunas personas que lamentaron el hecho de que por qué tantos adornos, para algo que también podría escribirse como Array#[1], Array#[2] (y Array#[ 41]).</p>

      <p>Ambas soluciones me hacen sonreír hasta el día de hoy. Estoy feliz de escribir a la gente, tercero como un caso de prueba en la consola. No, esto no es lógico. No es eficaz. Pero me hace sonreír y seguir los principios para enriquecer mi vida, y ayuda a justificar mi involucración continua con Rails despues de 12 años.</p>

      <p>A diferencia, por ejemplo, de la optimización del rendimiento, es difícil medir la optimización de la felicidad. Esto hizo que fuera casi anticientífica en su esencia, lo que para algunos lo hace menos importante, si no completamente frustrante. A los programadores se les enseña a discutir y operar con asuntos medibles, en los que se puede sacar una conclusión clara, donde A es categóricamente mejor que B.</p>

      <p>Pero mientras que la búsqueda de la felicidad es difícil de medir en el nivel micro, es mucho más claro observar en el nivel macro. La comunidad de Ruby on Rails está llena de personas que están aquí precisamente por esta búsqueda. Se jactan de mejores, más vidas realizadas en el ámbito laboral. Es en este conjunto de emociones que la victoria es clara.</p>

      <p>Entonces, concluimos: la optimización para la felicidad es quizás la clave más formativa de Ruby on Rails. Seguirá siendo así en adelante.</p>

      <h2 id="convention-over-configuration">Convención sobre configuración</h2>

      <p>Uno de los primeros lemas de Rails fue: "No eres un hermoso y único copo de nieve". El lema decía que al abandonar la individualidad, es posible evitar la solución de problemas triviales y avanzar más rápidamente en áreas que son realmente importantes.</p>

      <p>¿A quién le importa en qué formato se describen sus claves principales en la base de datos? ¿Es esto realmente importante cuando se trata de id, postId, posts_id o pid? ¿Es esta solución digna de discusión constante? No.</p>

      <p>Parte de la misión de Rails es hacer girar un machete en la jungla densa y que está constante crecimiento de soluciones repetitivas que enfrentan los desarrolladores que crean sistemas de información para la web. Hay miles de decisiones de este tipo que solo deben tomarse una vez, y si alguien más puede hacerlo por usted, mucho mejor.</p>

      <p>La transferencia de la configuración a la convención no solo nos libera de la discusión, también proporciona un campo exuberante para el crecimiento de abstracciones más profundas. Si tenemos la capacidad de usar la dependencia de la clase Persona en la tabla de personas, entonces podemos usar la misma transformación para mostrar la asociación, declarada como has_many: personas, para buscar la clase Persona. La fortaleza de las buenas convenciones es que generan dividendos en una amplia gama de usos.</p>

      <p>Pero además de las ganancias en la productividad para los expertos, las convenciones también reducen las barreras de entrada para los novatos. En Rails, hay muchos convenciones que un novato ni siquiera necesita conocer, pero que simplemente puede beneficiarse de su propia ignorancia. Es posible crear grandes aplicaciones sin saber por qué todo funciona de esa manera.</p>

      <p>Eso no es posible si su entorno de trabajo es simplemente un libro de texto grueso y su nueva aplicación es una hoja de papel en blanco. Se necesita un esfuerzo inmenso para averiguar dónde y cómo empezar. La mitad de la batalla para ponerse en marcha es encontrar un hilo del cual tirar.</p>

      <p>Lo mismo ocurre incluso cuando entiendes cómo todas las piezas van juntas. Cuando hay un próximo paso obvio para cada cambio, podemos desplazarnos a través de las muchas partes de una aplicación que es igual o muy similar a todas las demás aplicaciones que la precedieron. Un lugar para cada cosa y cada cosa en su lugar. Las restricciones liberan incluso a las mentes más capaces.</p>

      <p>Sin embargo, como con cualquier cosa, el poder de la convención no viene sin peligro. Cuando Rails hace que sea tan trivial hacer tanto, es fácil pensar que todos los aspectos de una aplicación pueden estar formados por plantillas pre-definidas. Pero la mayoría de las aplicaciones que vale la pena construir tienen algunos elementos que son únicos de alguna manera. Puede que solo sea el 5% o 1%, pero está ahí.</p>

      <p>La parte más difícil es saber cuándo dejar las convenciones. ¿Cuándo son las razones lo suficientemente serias para justificar esta decisión? Sostengo que la mayoría de los requisitos previos para ser un hermoso y único copo de nieve son poco considerados, y el costo de desviarse de Rails está subestimado. De hecho, hay un precio y usted debe reflexionar profundamente.</p>

      <h2 id="omakase">La carta al estilo omakase</h2>

      <p>¿Cómo sabes lo qué debes pedir en un restaurante cuando no sabes lo que es bueno? Bien, si dejas que el chef elija por ti, probablemente pueda sugerir una buena comida, incluso antes de que tu sepas qué es lo "bueno". Eso es omakase. Una forma de comer bien que no requiere ser un experto en comidas o probar suerte para ordenar cosas buenas.</p>

      <p>En la programación, el beneficio de el uso de esta práctica es que otros armen su stack tecnologico, similar a los argumentos que obtenemos de la convención sobre la configuración, pero va un paso más allá. CoC considera cómo utilizar mejor un framework individual, mientras que Omakase considera <em>qué</em> framework usar y cómo colaborar entre framework.</p>

      <p>Esto está en desacuerdo con la venerada tradición en la programación de querer presentar las herramientas disponibles como opciones individuales, y otorgarle al programador individual el privilegio (y la carga!) de decidir.</p>

      <p>Probablemente escuchó, y lo más probable, es que asintió con la cabeza en el momento en que alguien le dijo "use la mejor herramienta en el trabajo". Suena tan elemental que ni siquiera se puede discutir, pero la capacidad de elegir la "mejor herramienta" depende de las bases que le permiten determinar lo "mejor" con plena confianza. Esto es mucho más difícil de lo que parece.</p>

      <p>Este es un problema como el de la cena en un restaurante. Cómo elegir entre ocho platos, entonces la elección de una libreria o framework no debe ser un trabajo aislado. El objetivo en ambos casos es considerar toda la noche o el sistema.</p>

      <p>Por lo tanto, en Rails decidimos reducir la elección, reemplazar la elección individual de un programador de herramientas individuales con algo más grande: Un mejor conjunto de herramientas para todos. Los dividendos son legión:</p>

      <p><ol><li><b>Hay seguridad en los números:</b> Cuando la mayoría de las personas utilizan Rails de la misma forma predeterminada, tenemos una experiencia compartida. Este terreno común hace que sea mucho más fácil enseñar y ayudar a las personas. Sienta una base para el debate sobre el enfoque. Todos vimos el mismo programa anoche a las 7, así que podemos hablar sobre ello al día siguiente. Fomenta un sentido más fuerte de comunidad.</li>

      <li><b>La gente está perfeccionando la misma caja de herramientas básica:</b> Como full-stack framework, Rails tiene muchas partes móviles, y la forma en que trabajan juntas es tan importante como lo que hacen de forma aislada. Gran parte del sufrimiento en el software no proviene de los componentes individuales, sino de su interacción. Cuando todos trabajamos para aliviar el sufrimiento compartido de los componentes que están configurados y fallan de la misma manera, todos experimentamos menos sufrimiento.</li>

      <li><b>Las sustituciones siguen siendo posibles, pero no son necesarias:</b> Si bien Rails es una stack omakase, todavía te permite reemplazar ciertos frameworks o librerias con alternativas. Simplemente no requiere que lo hagas. Lo que significa que puede retrasar esas decisiones hasta que haya desarrollado una paleta clara y personal que puede preferir la diferencia ocasional.</li>
      </ol></p>

      <p>Porque incluso los programadores más expertos y capacitados que vienen y se quedan en Rails probablemente no se oponen a todos los asuntos del menú. (Si lo hicieran, no se habrían quedado con Rails). Así que eligen sus sustituciones con diligencia y luego continúan disfrutando del resto del stack compartido junto con todos los demás.</p>

      <h2 id="no-one-paradigm">Ningún paradigma</h2>

      <p>Hay un fuerte atractivo emocional para elegir una sola idea central y seguirla hasta la conclusión lógica como su base arquitectónica. Hay una pureza en tal disciplina, así que está claro por qué los programadores se sienten atraídos naturalmente por esta luz brillante.</p>

      <p>Rails no es así. No es un solo corte perfecto de tela. Es una colcha. Un compuesto de muchas ideas diferentes e incluso paradigmas. Muchos que normalmente se verían en conflicto, si se contrastan solos y uno por uno. Pero eso no es lo que estamos tratando de hacer. No es un solo campeonato de ideas superiores donde se debe declarar un único ganador.</p>

      <p>Tome las plantillas con las que creamos una vista en nuestro pastel Rails-MVC. Por defecto, todos los helpers que nos permiten extraer código de estas plantillas son simplemente un gran conjunto de metodos. Este es un solo namespace. ¡Oh, la sorpresa y el horror, es como una sopa de PHP!</p>

      <p>Pero sostengo que PHP tenía razón cuando se trataba de presentar funciones individuales que rara vez necesitaban interactuar, como ocurre con mucha abstracción en las vistas. Y para este propósito, el namespace, el gran conjunto de metodos, no solo es una opción razonable, sino una excelente.</p>

      <p>Esto no significa que no queramos ocasionalmente buscar algo más orientado a objetos al construir vistas. El concepto de Presenters, en el que envolvemos muchos métodos que son interdependientes entre sí y los datos que se encuentran bajo ellos, en ocasiones puede ser el antídoto perfecto para una sopa de métodos que se vuelven amargos por las dependencias. Pero, como regla general, resulta ser un caso raro, y no es común.</p>

      <p>En comparación, generalmente tratamos el modelo en nuestro pastel de capas MVC como el bastión principal del enfoque orientada a objetos. Encontrar el nombre correcto para los objetos, aumentar la coherencia y reducir el acoplamiento es lo divertido del modelado de dominios. Es una capa muy diferente de la vista, por lo que adoptamos un enfoque diferente.</p>

      <p>Pero incluso aquí no nos suscribimos al dogma de paradigma único. Las preocupaciones de Rails, la especialización de los mixins de Ruby, se utilizan a menudo para dar a los modelos individuales un área de covertura muy amplia. Esto encaja bien con el patrón Active Record al dar a los métodos en cuestión acceso directo a los datos y el almacenamiento con el que interactúan.</p>

      <p>Incluso la base misma de Active Record ofende a algunos puristas. Estamos mezclando la lógica necesaria para interactuar con la base de datos directamente con el dominio y la lógica de negocios. ¡Qué combinación de límites! Sí, porque resultó ser una forma práctica de envolver una aplicación web que casi siempre tiene una conexión a la base de datos para mantener el estado del modelo de dominio.</p>

      <p>Ser tan ideológicamente flexible es lo que permite a Rails abordar una amplia gama de problemas. La mayoría de los paradigmas individuales funcionan muy bien dentro una cierta porción del espacio problemático, pero se vuelven torpes o rígidos cuando se aplican más allá de su esfera natural de confort. Al aplicar muchos paradigmas superpuestos, cubrimos los flancos y protegemos la parte posterior. El framework final es mucho más fuerte y más capaz de lo que cualquier paradigma individual lo hubiera permitido.</p>

      <p>Ahora, el costo de esta relación poliamorosa con los muchos paradigmas de la programación es una sobrecarga conceptual. No es suficiente saber la programación orientada a objetos para pasar un buen rato con Rails. Es preferible darse bien servido con programación por procedimientos y funcional también.</p>

      <p>Esto se aplica a los muchos sub-idiomas de Rails también. No intentamos protegerlo tanto de tener que aprender, por ejemplo, JavaScript para las vistas o SQL para las consultas ocacionalmente complicadas. Al menos no para alcanzar los picos de posibilidades.</p>

      <p>La forma de aliviar algo de esa carga de aprendizaje es simplemente hacer que sea fácil comenzar, hacer algo de valor real, antes de que se entienda cada aspecto del framework. Por este motivo, tenemos prisa por mostrar el típico "Hello World". Ya está lista la mesa e incluye un aperitivo servido.</p>

      <p>La idea es que al dar algo de valor real tempranamente, animamos a los practicantes de Rails a subir su nivel rápidamente. Aceptar su viaje de aprendizaje con alegría, no con obstáculos.</p>

    </section>
